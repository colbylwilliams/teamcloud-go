//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package teamcloud

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client contains the methods for the TeamCloud group.
// Don't use this type directly, use NewClient() instead.
type Client struct {
	pl runtime.Pipeline
}

// NewClient creates a new instance of Client with the specified values.
// options - pass nil to accept the default values.
func NewClient(options *azcore.ClientOptions) *Client {
	if options == nil {
		options = &azcore.ClientOptions{}
	}
	client := &Client{
		pl: runtime.NewPipeline(moduleName, moduleVersion, runtime.PipelineOptions{}, options),
	}
	return client
}

// CancelComponentTask - Cancel a Project Component Task.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCancelComponentTaskOptions contains the optional parameters for the Client.CancelComponentTask method.
func (client *Client) CancelComponentTask(ctx context.Context, organizationID string, projectID string, componentID string, taskID string, options *ClientCancelComponentTaskOptions) (ClientCancelComponentTaskResponse, error) {
	req, err := client.cancelComponentTaskCreateRequest(ctx, organizationID, projectID, componentID, taskID, options)
	if err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientCancelComponentTaskResponse{}, runtime.NewResponseError(resp)
	}
	return client.cancelComponentTaskHandleResponse(resp)
}

// cancelComponentTaskCreateRequest creates the CancelComponentTask request.
func (client *Client) cancelComponentTaskCreateRequest(ctx context.Context, organizationID string, projectID string, componentID string, taskID string, options *ClientCancelComponentTaskOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/cancel"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// cancelComponentTaskHandleResponse handles the CancelComponentTask response.
func (client *Client) cancelComponentTaskHandleResponse(resp *http.Response) (ClientCancelComponentTaskResponse, error) {
	result := ClientCancelComponentTaskResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentTaskDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCancelComponentTaskResponse{}, err
	}
	result.Value = val
	default:
		return ClientCancelComponentTaskResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateComponent - Creates a new Project Component.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateComponentOptions contains the optional parameters for the Client.CreateComponent method.
func (client *Client) CreateComponent(ctx context.Context, organizationID string, projectID string, options *ClientCreateComponentOptions) (ClientCreateComponentResponse, error) {
	req, err := client.createComponentCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientCreateComponentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateComponentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateComponentResponse{}, runtime.NewResponseError(resp)
	}
	return client.createComponentHandleResponse(resp)
}

// createComponentCreateRequest creates the CreateComponent request.
func (client *Client) createComponentCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientCreateComponentOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createComponentHandleResponse handles the CreateComponent response.
func (client *Client) createComponentHandleResponse(resp *http.Response) (ClientCreateComponentResponse, error) {
	result := ClientCreateComponentResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ComponentDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateComponentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateComponentTask - Creates a new Project Component Task.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateComponentTaskOptions contains the optional parameters for the Client.CreateComponentTask method.
func (client *Client) CreateComponentTask(ctx context.Context, organizationID string, projectID string, componentID string, options *ClientCreateComponentTaskOptions) (ClientCreateComponentTaskResponse, error) {
	req, err := client.createComponentTaskCreateRequest(ctx, organizationID, projectID, componentID, options)
	if err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateComponentTaskResponse{}, runtime.NewResponseError(resp)
	}
	return client.createComponentTaskHandleResponse(resp)
}

// createComponentTaskCreateRequest creates the CreateComponentTask request.
func (client *Client) createComponentTaskCreateRequest(ctx context.Context, organizationID string, projectID string, componentID string, options *ClientCreateComponentTaskOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createComponentTaskHandleResponse handles the CreateComponentTask response.
func (client *Client) createComponentTaskHandleResponse(resp *http.Response) (ClientCreateComponentTaskResponse, error) {
	result := ClientCreateComponentTaskResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ComponentTaskDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateComponentTaskResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateComponentTaskResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateDeploymentScope - Creates a new Deployment Scope.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateDeploymentScopeOptions contains the optional parameters for the Client.CreateDeploymentScope method.
func (client *Client) CreateDeploymentScope(ctx context.Context, organizationID string, options *ClientCreateDeploymentScopeOptions) (ClientCreateDeploymentScopeResponse, error) {
	req, err := client.createDeploymentScopeCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientCreateDeploymentScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateDeploymentScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict) {
		return ClientCreateDeploymentScopeResponse{}, runtime.NewResponseError(resp)
	}
	return client.createDeploymentScopeHandleResponse(resp)
}

// createDeploymentScopeCreateRequest creates the CreateDeploymentScope request.
func (client *Client) createDeploymentScopeCreateRequest(ctx context.Context, organizationID string, options *ClientCreateDeploymentScopeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createDeploymentScopeHandleResponse handles the CreateDeploymentScope response.
func (client *Client) createDeploymentScopeHandleResponse(resp *http.Response) (ClientCreateDeploymentScopeResponse, error) {
	result := ClientCreateDeploymentScopeResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val DeploymentScopeDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateDeploymentScopeResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateDeploymentScopeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateOrganization - Creates a new Organization.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateOrganizationOptions contains the optional parameters for the Client.CreateOrganization method.
func (client *Client) CreateOrganization(ctx context.Context, options *ClientCreateOrganizationOptions) (ClientCreateOrganizationResponse, error) {
	req, err := client.createOrganizationCreateRequest(ctx, options)
	if err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrganizationHandleResponse(resp)
}

// createOrganizationCreateRequest creates the CreateOrganization request.
func (client *Client) createOrganizationCreateRequest(ctx context.Context, options *ClientCreateOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createOrganizationHandleResponse handles the CreateOrganization response.
func (client *Client) createOrganizationHandleResponse(resp *http.Response) (ClientCreateOrganizationResponse, error) {
	result := ClientCreateOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val OrganizationDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateOrganizationUser - Creates a new User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateOrganizationUserOptions contains the optional parameters for the Client.CreateOrganizationUser method.
func (client *Client) CreateOrganizationUser(ctx context.Context, organizationID string, options *ClientCreateOrganizationUserOptions) (ClientCreateOrganizationUserResponse, error) {
	req, err := client.createOrganizationUserCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateOrganizationUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrganizationUserHandleResponse(resp)
}

// createOrganizationUserCreateRequest creates the CreateOrganizationUser request.
func (client *Client) createOrganizationUserCreateRequest(ctx context.Context, organizationID string, options *ClientCreateOrganizationUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createOrganizationUserHandleResponse handles the CreateOrganizationUser response.
func (client *Client) createOrganizationUserHandleResponse(resp *http.Response) (ClientCreateOrganizationUserResponse, error) {
	result := ClientCreateOrganizationUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateOrganizationUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateOrganizationUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateProject - Creates a new Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateProjectOptions contains the optional parameters for the Client.CreateProject method.
func (client *Client) CreateProject(ctx context.Context, organizationID string, options *ClientCreateProjectOptions) (ClientCreateProjectResponse, error) {
	req, err := client.createProjectCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientCreateProjectResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateProjectResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict) {
		return ClientCreateProjectResponse{}, runtime.NewResponseError(resp)
	}
	return client.createProjectHandleResponse(resp)
}

// createProjectCreateRequest creates the CreateProject request.
func (client *Client) createProjectCreateRequest(ctx context.Context, organizationID string, options *ClientCreateProjectOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createProjectHandleResponse handles the CreateProject response.
func (client *Client) createProjectHandleResponse(resp *http.Response) (ClientCreateProjectResponse, error) {
	result := ClientCreateProjectResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ProjectDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateProjectResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateProjectIdentity - Creates a new Project Identity.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateProjectIdentityOptions contains the optional parameters for the Client.CreateProjectIdentity method.
func (client *Client) CreateProjectIdentity(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectIdentityOptions) (ClientCreateProjectIdentityResponse, error) {
	req, err := client.createProjectIdentityCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientCreateProjectIdentityResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateProjectIdentityResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict) {
		return ClientCreateProjectIdentityResponse{}, runtime.NewResponseError(resp)
	}
	return client.createProjectIdentityHandleResponse(resp)
}

// createProjectIdentityCreateRequest creates the CreateProjectIdentity request.
func (client *Client) createProjectIdentityCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectIdentityOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/identities"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createProjectIdentityHandleResponse handles the CreateProjectIdentity response.
func (client *Client) createProjectIdentityHandleResponse(resp *http.Response) (ClientCreateProjectIdentityResponse, error) {
	result := ClientCreateProjectIdentityResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ProjectIdentityDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectIdentityResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateProjectIdentityResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateProjectTag - Creates a new Project Tag.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateProjectTagOptions contains the optional parameters for the Client.CreateProjectTag method.
func (client *Client) CreateProjectTag(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectTagOptions) (ClientCreateProjectTagResponse, error) {
	req, err := client.createProjectTagCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateProjectTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.createProjectTagHandleResponse(resp)
}

// createProjectTagCreateRequest creates the CreateProjectTag request.
func (client *Client) createProjectTagCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectTagOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/tags"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, options.Body)
	}
	return req, nil
}

// createProjectTagHandleResponse handles the CreateProjectTag response.
func (client *Client) createProjectTagHandleResponse(resp *http.Response) (ClientCreateProjectTagResponse, error) {
	result := ClientCreateProjectTagResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTagResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateProjectTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateProjectTemplate - Creates a new Project Template.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateProjectTemplateOptions contains the optional parameters for the Client.CreateProjectTemplate method.
func (client *Client) CreateProjectTemplate(ctx context.Context, organizationID string, options *ClientCreateProjectTemplateOptions) (ClientCreateProjectTemplateResponse, error) {
	req, err := client.createProjectTemplateCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientCreateProjectTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateProjectTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict) {
		return ClientCreateProjectTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createProjectTemplateHandleResponse(resp)
}

// createProjectTemplateCreateRequest creates the CreateProjectTemplate request.
func (client *Client) createProjectTemplateCreateRequest(ctx context.Context, organizationID string, options *ClientCreateProjectTemplateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/templates"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createProjectTemplateHandleResponse handles the CreateProjectTemplate response.
func (client *Client) createProjectTemplateHandleResponse(resp *http.Response) (ClientCreateProjectTemplateResponse, error) {
	result := ClientCreateProjectTemplateResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ProjectTemplateDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectTemplateResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateProjectTemplateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateProjectUser - Creates a new Project User
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateProjectUserOptions contains the optional parameters for the Client.CreateProjectUser method.
func (client *Client) CreateProjectUser(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectUserOptions) (ClientCreateProjectUserResponse, error) {
	req, err := client.createProjectUserCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateProjectUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.createProjectUserHandleResponse(resp)
}

// createProjectUserCreateRequest creates the CreateProjectUser request.
func (client *Client) createProjectUserCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientCreateProjectUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createProjectUserHandleResponse handles the CreateProjectUser response.
func (client *Client) createProjectUserHandleResponse(resp *http.Response) (ClientCreateProjectUserResponse, error) {
	result := ClientCreateProjectUserResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateProjectUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateProjectUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// CreateSchedule - Creates a new Project Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientCreateScheduleOptions contains the optional parameters for the Client.CreateSchedule method.
func (client *Client) CreateSchedule(ctx context.Context, organizationID string, projectID string, options *ClientCreateScheduleOptions) (ClientCreateScheduleResponse, error) {
	req, err := client.createScheduleCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientCreateScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.createScheduleHandleResponse(resp)
}

// createScheduleCreateRequest creates the CreateSchedule request.
func (client *Client) createScheduleCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientCreateScheduleOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/schedules"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// createScheduleHandleResponse handles the CreateSchedule response.
func (client *Client) createScheduleHandleResponse(resp *http.Response) (ClientCreateScheduleResponse, error) {
	result := ClientCreateScheduleResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ScheduleDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientCreateScheduleResponse{}, err
	}
	result.Value = val
	default:
		return ClientCreateScheduleResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteComponent - Deletes an existing Project Component.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteComponentOptions contains the optional parameters for the Client.DeleteComponent method.
func (client *Client) DeleteComponent(ctx context.Context, componentID string, organizationID string, projectID string, options *ClientDeleteComponentOptions) (ClientDeleteComponentResponse, error) {
	req, err := client.deleteComponentCreateRequest(ctx, componentID, organizationID, projectID, options)
	if err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteComponentResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteComponentHandleResponse(resp)
}

// deleteComponentCreateRequest creates the DeleteComponent request.
func (client *Client) deleteComponentCreateRequest(ctx context.Context, componentID string, organizationID string, projectID string, options *ClientDeleteComponentOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}"
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteComponentHandleResponse handles the DeleteComponent response.
func (client *Client) deleteComponentHandleResponse(resp *http.Response) (ClientDeleteComponentResponse, error) {
	result := ClientDeleteComponentResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	var val ComponentDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteComponentResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteComponentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteDeploymentScope - Deletes a Deployment Scope.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteDeploymentScopeOptions contains the optional parameters for the Client.DeleteDeploymentScope method.
func (client *Client) DeleteDeploymentScope(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientDeleteDeploymentScopeOptions) (ClientDeleteDeploymentScopeResponse, error) {
	req, err := client.deleteDeploymentScopeCreateRequest(ctx, organizationID, deploymentScopeID, options)
	if err != nil {
		return ClientDeleteDeploymentScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteDeploymentScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteDeploymentScopeResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteDeploymentScopeHandleResponse(resp)
}

// deleteDeploymentScopeCreateRequest creates the DeleteDeploymentScope request.
func (client *Client) deleteDeploymentScopeCreateRequest(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientDeleteDeploymentScopeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes/{deploymentScopeId}"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if deploymentScopeID == "" {
		return nil, errors.New("parameter deploymentScopeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentScopeId}", url.PathEscape(deploymentScopeID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDeploymentScopeHandleResponse handles the DeleteDeploymentScope response.
func (client *Client) deleteDeploymentScopeHandleResponse(resp *http.Response) (ClientDeleteDeploymentScopeResponse, error) {
	result := ClientDeleteDeploymentScopeResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	var val DeploymentScopeDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteDeploymentScopeResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteDeploymentScopeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteOrganization - Deletes an existing Organization.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteOrganizationOptions contains the optional parameters for the Client.DeleteOrganization method.
func (client *Client) DeleteOrganization(ctx context.Context, organizationID string, options *ClientDeleteOrganizationOptions) (ClientDeleteOrganizationResponse, error) {
	req, err := client.deleteOrganizationCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientDeleteOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteOrganizationHandleResponse(resp)
}

// deleteOrganizationCreateRequest creates the DeleteOrganization request.
func (client *Client) deleteOrganizationCreateRequest(ctx context.Context, organizationID string, options *ClientDeleteOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteOrganizationHandleResponse handles the DeleteOrganization response.
func (client *Client) deleteOrganizationHandleResponse(resp *http.Response) (ClientDeleteOrganizationResponse, error) {
	result := ClientDeleteOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteOrganizationUser - Deletes an existing User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteOrganizationUserOptions contains the optional parameters for the Client.DeleteOrganizationUser method.
func (client *Client) DeleteOrganizationUser(ctx context.Context, userID string, organizationID string, options *ClientDeleteOrganizationUserOptions) (ClientDeleteOrganizationUserResponse, error) {
	req, err := client.deleteOrganizationUserCreateRequest(ctx, userID, organizationID, options)
	if err != nil {
		return ClientDeleteOrganizationUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteOrganizationUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteOrganizationUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteOrganizationUserHandleResponse(resp)
}

// deleteOrganizationUserCreateRequest creates the DeleteOrganizationUser request.
func (client *Client) deleteOrganizationUserCreateRequest(ctx context.Context, userID string, organizationID string, options *ClientDeleteOrganizationUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteOrganizationUserHandleResponse handles the DeleteOrganizationUser response.
func (client *Client) deleteOrganizationUserHandleResponse(resp *http.Response) (ClientDeleteOrganizationUserResponse, error) {
	result := ClientDeleteOrganizationUserResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusNoContent:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteOrganizationUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteOrganizationUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteProject - Deletes a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteProjectOptions contains the optional parameters for the Client.DeleteProject method.
func (client *Client) DeleteProject(ctx context.Context, projectID string, organizationID string, options *ClientDeleteProjectOptions) (ClientDeleteProjectResponse, error) {
	req, err := client.deleteProjectCreateRequest(ctx, projectID, organizationID, options)
	if err != nil {
		return ClientDeleteProjectResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteProjectResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteProjectResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteProjectHandleResponse(resp)
}

// deleteProjectCreateRequest creates the DeleteProject request.
func (client *Client) deleteProjectCreateRequest(ctx context.Context, projectID string, organizationID string, options *ClientDeleteProjectOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}"
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProjectHandleResponse handles the DeleteProject response.
func (client *Client) deleteProjectHandleResponse(resp *http.Response) (ClientDeleteProjectResponse, error) {
	result := ClientDeleteProjectResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteProjectResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteProjectIdentity - Deletes a Project Identity.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteProjectIdentityOptions contains the optional parameters for the Client.DeleteProjectIdentity method.
func (client *Client) DeleteProjectIdentity(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientDeleteProjectIdentityOptions) (ClientDeleteProjectIdentityResponse, error) {
	req, err := client.deleteProjectIdentityCreateRequest(ctx, projectIdentityID, organizationID, projectID, options)
	if err != nil {
		return ClientDeleteProjectIdentityResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteProjectIdentityResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteProjectIdentityResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteProjectIdentityHandleResponse(resp)
}

// deleteProjectIdentityCreateRequest creates the DeleteProjectIdentity request.
func (client *Client) deleteProjectIdentityCreateRequest(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientDeleteProjectIdentityOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"
	if projectIdentityID == "" {
		return nil, errors.New("parameter projectIdentityID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectIdentityId}", url.PathEscape(projectIdentityID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProjectIdentityHandleResponse handles the DeleteProjectIdentity response.
func (client *Client) deleteProjectIdentityHandleResponse(resp *http.Response) (ClientDeleteProjectIdentityResponse, error) {
	result := ClientDeleteProjectIdentityResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	var val ProjectIdentityDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectIdentityResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteProjectIdentityResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteProjectTag - Deletes an existing Project Tag.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteProjectTagOptions contains the optional parameters for the Client.DeleteProjectTag method.
func (client *Client) DeleteProjectTag(ctx context.Context, tagKey string, organizationID string, projectID string, options *ClientDeleteProjectTagOptions) (ClientDeleteProjectTagResponse, error) {
	req, err := client.deleteProjectTagCreateRequest(ctx, tagKey, organizationID, projectID, options)
	if err != nil {
		return ClientDeleteProjectTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteProjectTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteProjectTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteProjectTagHandleResponse(resp)
}

// deleteProjectTagCreateRequest creates the DeleteProjectTag request.
func (client *Client) deleteProjectTagCreateRequest(ctx context.Context, tagKey string, organizationID string, projectID string, options *ClientDeleteProjectTagOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}"
	if tagKey == "" {
		return nil, errors.New("parameter tagKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tagKey}", url.PathEscape(tagKey))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProjectTagHandleResponse handles the DeleteProjectTag response.
func (client *Client) deleteProjectTagHandleResponse(resp *http.Response) (ClientDeleteProjectTagResponse, error) {
	result := ClientDeleteProjectTagResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTagResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteProjectTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteProjectTemplate - Deletes a Project Template.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteProjectTemplateOptions contains the optional parameters for the Client.DeleteProjectTemplate method.
func (client *Client) DeleteProjectTemplate(ctx context.Context, projectTemplateID string, organizationID string, options *ClientDeleteProjectTemplateOptions) (ClientDeleteProjectTemplateResponse, error) {
	req, err := client.deleteProjectTemplateCreateRequest(ctx, projectTemplateID, organizationID, options)
	if err != nil {
		return ClientDeleteProjectTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteProjectTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteProjectTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteProjectTemplateHandleResponse(resp)
}

// deleteProjectTemplateCreateRequest creates the DeleteProjectTemplate request.
func (client *Client) deleteProjectTemplateCreateRequest(ctx context.Context, projectTemplateID string, organizationID string, options *ClientDeleteProjectTemplateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/templates/{projectTemplateId}"
	if projectTemplateID == "" {
		return nil, errors.New("parameter projectTemplateID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectTemplateId}", url.PathEscape(projectTemplateID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProjectTemplateHandleResponse handles the DeleteProjectTemplate response.
func (client *Client) deleteProjectTemplateHandleResponse(resp *http.Response) (ClientDeleteProjectTemplateResponse, error) {
	result := ClientDeleteProjectTemplateResponse{}
	switch resp.StatusCode {
	case http.StatusNoContent:
	var val ProjectTemplateDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectTemplateResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteProjectTemplateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// DeleteProjectUser - Deletes an existing Project User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientDeleteProjectUserOptions contains the optional parameters for the Client.DeleteProjectUser method.
func (client *Client) DeleteProjectUser(ctx context.Context, userID string, organizationID string, projectID string, options *ClientDeleteProjectUserOptions) (ClientDeleteProjectUserResponse, error) {
	req, err := client.deleteProjectUserCreateRequest(ctx, userID, organizationID, projectID, options)
	if err != nil {
		return ClientDeleteProjectUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteProjectUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientDeleteProjectUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteProjectUserHandleResponse(resp)
}

// deleteProjectUserCreateRequest creates the DeleteProjectUser request.
func (client *Client) deleteProjectUserCreateRequest(ctx context.Context, userID string, organizationID string, projectID string, options *ClientDeleteProjectUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProjectUserHandleResponse handles the DeleteProjectUser response.
func (client *Client) deleteProjectUserHandleResponse(resp *http.Response) (ClientDeleteProjectUserResponse, error) {
	result := ClientDeleteProjectUserResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientDeleteProjectUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientDeleteProjectUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetAdapters - Gets all Adapters.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetAdaptersOptions contains the optional parameters for the Client.GetAdapters method.
func (client *Client) GetAdapters(ctx context.Context, options *ClientGetAdaptersOptions) (ClientGetAdaptersResponse, error) {
	req, err := client.getAdaptersCreateRequest(ctx, options)
	if err != nil {
		return ClientGetAdaptersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetAdaptersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetAdaptersResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAdaptersHandleResponse(resp)
}

// getAdaptersCreateRequest creates the GetAdapters request.
func (client *Client) getAdaptersCreateRequest(ctx context.Context, options *ClientGetAdaptersOptions) (*policy.Request, error) {
	urlPath := "/adapters"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAdaptersHandleResponse handles the GetAdapters response.
func (client *Client) getAdaptersHandleResponse(resp *http.Response) (ClientGetAdaptersResponse, error) {
	result := ClientGetAdaptersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val AdapterInformationListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAdaptersResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAdaptersResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetAdaptersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetAuditCommands - Gets all auditable commands.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetAuditCommandsOptions contains the optional parameters for the Client.GetAuditCommands method.
func (client *Client) GetAuditCommands(ctx context.Context, organizationID string, options *ClientGetAuditCommandsOptions) (ClientGetAuditCommandsResponse, error) {
	req, err := client.getAuditCommandsCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetAuditCommandsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetAuditCommandsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetAuditCommandsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAuditCommandsHandleResponse(resp)
}

// getAuditCommandsCreateRequest creates the GetAuditCommands request.
func (client *Client) getAuditCommandsCreateRequest(ctx context.Context, organizationID string, options *ClientGetAuditCommandsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/audit/commands"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuditCommandsHandleResponse handles the GetAuditCommands response.
func (client *Client) getAuditCommandsHandleResponse(resp *http.Response) (ClientGetAuditCommandsResponse, error) {
	result := ClientGetAuditCommandsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StringListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditCommandsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditCommandsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditCommandsResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetAuditCommandsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetAuditEntries - Gets all audit entries.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetAuditEntriesOptions contains the optional parameters for the Client.GetAuditEntries method.
func (client *Client) GetAuditEntries(ctx context.Context, organizationID string, options *ClientGetAuditEntriesOptions) (ClientGetAuditEntriesResponse, error) {
	req, err := client.getAuditEntriesCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetAuditEntriesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetAuditEntriesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetAuditEntriesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAuditEntriesHandleResponse(resp)
}

// getAuditEntriesCreateRequest creates the GetAuditEntries request.
func (client *Client) getAuditEntriesCreateRequest(ctx context.Context, organizationID string, options *ClientGetAuditEntriesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/audit"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.TimeRange != nil {
		reqQP.Set("timeRange", *options.TimeRange)
	}
	if options != nil && options.Commands != nil {
		reqQP.Set("commands", strings.Join(options.Commands, ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuditEntriesHandleResponse handles the GetAuditEntries response.
func (client *Client) getAuditEntriesHandleResponse(resp *http.Response) (ClientGetAuditEntriesResponse, error) {
	result := ClientGetAuditEntriesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CommandAuditEntityListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntriesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntriesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntriesResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetAuditEntriesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetAuditEntry - Gets an audit entry.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetAuditEntryOptions contains the optional parameters for the Client.GetAuditEntry method.
func (client *Client) GetAuditEntry(ctx context.Context, commandID string, organizationID string, options *ClientGetAuditEntryOptions) (ClientGetAuditEntryResponse, error) {
	req, err := client.getAuditEntryCreateRequest(ctx, commandID, organizationID, options)
	if err != nil {
		return ClientGetAuditEntryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetAuditEntryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetAuditEntryResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAuditEntryHandleResponse(resp)
}

// getAuditEntryCreateRequest creates the GetAuditEntry request.
func (client *Client) getAuditEntryCreateRequest(ctx context.Context, commandID string, organizationID string, options *ClientGetAuditEntryOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/audit/{commandId}"
	urlPath = strings.ReplaceAll(urlPath, "{commandId}", url.PathEscape(commandID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("expand", strconv.FormatBool(*options.Expand))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuditEntryHandleResponse handles the GetAuditEntry response.
func (client *Client) getAuditEntryHandleResponse(resp *http.Response) (ClientGetAuditEntryResponse, error) {
	result := ClientGetAuditEntryResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val CommandAuditEntityDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntryResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntryResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetAuditEntryResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetAuditEntryResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponent - Gets a Project Component.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentOptions contains the optional parameters for the Client.GetComponent method.
func (client *Client) GetComponent(ctx context.Context, componentID string, organizationID string, projectID string, options *ClientGetComponentOptions) (ClientGetComponentResponse, error) {
	req, err := client.getComponentCreateRequest(ctx, componentID, organizationID, projectID, options)
	if err != nil {
		return ClientGetComponentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentHandleResponse(resp)
}

// getComponentCreateRequest creates the GetComponent request.
func (client *Client) getComponentCreateRequest(ctx context.Context, componentID string, organizationID string, projectID string, options *ClientGetComponentOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}"
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentHandleResponse handles the GetComponent response.
func (client *Client) getComponentHandleResponse(resp *http.Response) (ClientGetComponentResponse, error) {
	result := ClientGetComponentResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponentTask - Gets the Component Task.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentTaskOptions contains the optional parameters for the Client.GetComponentTask method.
func (client *Client) GetComponentTask(ctx context.Context, taskID string, organizationID string, projectID string, componentID string, options *ClientGetComponentTaskOptions) (ClientGetComponentTaskResponse, error) {
	req, err := client.getComponentTaskCreateRequest(ctx, taskID, organizationID, projectID, componentID, options)
	if err != nil {
		return ClientGetComponentTaskResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentTaskResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentTaskResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentTaskHandleResponse(resp)
}

// getComponentTaskCreateRequest creates the GetComponentTask request.
func (client *Client) getComponentTaskCreateRequest(ctx context.Context, taskID string, organizationID string, projectID string, componentID string, options *ClientGetComponentTaskOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}"
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentTaskHandleResponse handles the GetComponentTask response.
func (client *Client) getComponentTaskHandleResponse(resp *http.Response) (ClientGetComponentTaskResponse, error) {
	result := ClientGetComponentTaskResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentTaskDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTaskResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentTaskResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponentTasks - Gets all Component Tasks.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentTasksOptions contains the optional parameters for the Client.GetComponentTasks method.
func (client *Client) GetComponentTasks(ctx context.Context, organizationID string, projectID string, componentID string, options *ClientGetComponentTasksOptions) (ClientGetComponentTasksResponse, error) {
	req, err := client.getComponentTasksCreateRequest(ctx, organizationID, projectID, componentID, options)
	if err != nil {
		return ClientGetComponentTasksResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentTasksResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentTasksResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentTasksHandleResponse(resp)
}

// getComponentTasksCreateRequest creates the GetComponentTasks request.
func (client *Client) getComponentTasksCreateRequest(ctx context.Context, organizationID string, projectID string, componentID string, options *ClientGetComponentTasksOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentTasksHandleResponse handles the GetComponentTasks response.
func (client *Client) getComponentTasksHandleResponse(resp *http.Response) (ClientGetComponentTasksResponse, error) {
	result := ClientGetComponentTasksResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentTaskListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTasksResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTasksResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTasksResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentTasksResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponentTemplate - Gets the Component Template.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentTemplateOptions contains the optional parameters for the Client.GetComponentTemplate method.
func (client *Client) GetComponentTemplate(ctx context.Context, id string, organizationID string, projectID string, options *ClientGetComponentTemplateOptions) (ClientGetComponentTemplateResponse, error) {
	req, err := client.getComponentTemplateCreateRequest(ctx, id, organizationID, projectID, options)
	if err != nil {
		return ClientGetComponentTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentTemplateHandleResponse(resp)
}

// getComponentTemplateCreateRequest creates the GetComponentTemplate request.
func (client *Client) getComponentTemplateCreateRequest(ctx context.Context, id string, organizationID string, projectID string, options *ClientGetComponentTemplateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/templates/{id}"
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentTemplateHandleResponse handles the GetComponentTemplate response.
func (client *Client) getComponentTemplateHandleResponse(resp *http.Response) (ClientGetComponentTemplateResponse, error) {
	result := ClientGetComponentTemplateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentTemplateDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplateResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentTemplateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponentTemplates - Gets all Component Templates for a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentTemplatesOptions contains the optional parameters for the Client.GetComponentTemplates method.
func (client *Client) GetComponentTemplates(ctx context.Context, organizationID string, projectID string, options *ClientGetComponentTemplatesOptions) (ClientGetComponentTemplatesResponse, error) {
	req, err := client.getComponentTemplatesCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetComponentTemplatesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentTemplatesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentTemplatesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentTemplatesHandleResponse(resp)
}

// getComponentTemplatesCreateRequest creates the GetComponentTemplates request.
func (client *Client) getComponentTemplatesCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetComponentTemplatesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/templates"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentTemplatesHandleResponse handles the GetComponentTemplates response.
func (client *Client) getComponentTemplatesHandleResponse(resp *http.Response) (ClientGetComponentTemplatesResponse, error) {
	result := ClientGetComponentTemplatesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentTemplateListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplatesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplatesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentTemplatesResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentTemplatesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetComponents - Gets all Components for a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetComponentsOptions contains the optional parameters for the Client.GetComponents method.
func (client *Client) GetComponents(ctx context.Context, organizationID string, projectID string, options *ClientGetComponentsOptions) (ClientGetComponentsResponse, error) {
	req, err := client.getComponentsCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetComponentsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetComponentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetComponentsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getComponentsHandleResponse(resp)
}

// getComponentsCreateRequest creates the GetComponents request.
func (client *Client) getComponentsCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetComponentsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Deleted != nil {
		reqQP.Set("deleted", strconv.FormatBool(*options.Deleted))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getComponentsHandleResponse handles the GetComponents response.
func (client *Client) getComponentsHandleResponse(resp *http.Response) (ClientGetComponentsResponse, error) {
	result := ClientGetComponentsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ComponentListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetComponentsResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetComponentsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetDeploymentScope - Gets a Deployment Scope.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetDeploymentScopeOptions contains the optional parameters for the Client.GetDeploymentScope method.
func (client *Client) GetDeploymentScope(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientGetDeploymentScopeOptions) (ClientGetDeploymentScopeResponse, error) {
	req, err := client.getDeploymentScopeCreateRequest(ctx, organizationID, deploymentScopeID, options)
	if err != nil {
		return ClientGetDeploymentScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeploymentScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetDeploymentScopeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeploymentScopeHandleResponse(resp)
}

// getDeploymentScopeCreateRequest creates the GetDeploymentScope request.
func (client *Client) getDeploymentScopeCreateRequest(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientGetDeploymentScopeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes/{deploymentScopeId}"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if deploymentScopeID == "" {
		return nil, errors.New("parameter deploymentScopeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentScopeId}", url.PathEscape(deploymentScopeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentScopeHandleResponse handles the GetDeploymentScope response.
func (client *Client) getDeploymentScopeHandleResponse(resp *http.Response) (ClientGetDeploymentScopeResponse, error) {
	result := ClientGetDeploymentScopeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeploymentScopeDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetDeploymentScopeResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetDeploymentScopeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetDeploymentScopes - Gets all Deployment Scopes.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetDeploymentScopesOptions contains the optional parameters for the Client.GetDeploymentScopes method.
func (client *Client) GetDeploymentScopes(ctx context.Context, organizationID string, options *ClientGetDeploymentScopesOptions) (ClientGetDeploymentScopesResponse, error) {
	req, err := client.getDeploymentScopesCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetDeploymentScopesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetDeploymentScopesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetDeploymentScopesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getDeploymentScopesHandleResponse(resp)
}

// getDeploymentScopesCreateRequest creates the GetDeploymentScopes request.
func (client *Client) getDeploymentScopesCreateRequest(ctx context.Context, organizationID string, options *ClientGetDeploymentScopesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentScopesHandleResponse handles the GetDeploymentScopes response.
func (client *Client) getDeploymentScopesHandleResponse(resp *http.Response) (ClientGetDeploymentScopesResponse, error) {
	result := ClientGetDeploymentScopesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeploymentScopeListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetDeploymentScopesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetDeploymentScopesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetDeploymentScopesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetInfo - Gets information about this TeamCloud deployment.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetInfoOptions contains the optional parameters for the Client.GetInfo method.
func (client *Client) GetInfo(ctx context.Context, options *ClientGetInfoOptions) (ClientGetInfoResponse, error) {
	req, err := client.getInfoCreateRequest(ctx, options)
	if err != nil {
		return ClientGetInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetInfoResponse{}, runtime.NewResponseError(resp)
	}
	return client.getInfoHandleResponse(resp)
}

// getInfoCreateRequest creates the GetInfo request.
func (client *Client) getInfoCreateRequest(ctx context.Context, options *ClientGetInfoOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, 	host)
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInfoHandleResponse handles the GetInfo response.
func (client *Client) getInfoHandleResponse(resp *http.Response) (ClientGetInfoResponse, error) {
	result := ClientGetInfoResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.InformationDataResult); err != nil {
		return ClientGetInfoResponse{}, err
	}
	return result, nil
}

// GetOrganization - Gets an Organization.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetOrganizationOptions contains the optional parameters for the Client.GetOrganization method.
func (client *Client) GetOrganization(ctx context.Context, organizationID string, options *ClientGetOrganizationOptions) (ClientGetOrganizationResponse, error) {
	req, err := client.getOrganizationCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetOrganizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetOrganizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetOrganizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrganizationHandleResponse(resp)
}

// getOrganizationCreateRequest creates the GetOrganization request.
func (client *Client) getOrganizationCreateRequest(ctx context.Context, organizationID string, options *ClientGetOrganizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrganizationHandleResponse handles the GetOrganization response.
func (client *Client) getOrganizationHandleResponse(resp *http.Response) (ClientGetOrganizationResponse, error) {
	result := ClientGetOrganizationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrganizationDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetOrganizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetOrganizationUser - Gets a User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetOrganizationUserOptions contains the optional parameters for the Client.GetOrganizationUser method.
func (client *Client) GetOrganizationUser(ctx context.Context, userID string, organizationID string, options *ClientGetOrganizationUserOptions) (ClientGetOrganizationUserResponse, error) {
	req, err := client.getOrganizationUserCreateRequest(ctx, userID, organizationID, options)
	if err != nil {
		return ClientGetOrganizationUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetOrganizationUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetOrganizationUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrganizationUserHandleResponse(resp)
}

// getOrganizationUserCreateRequest creates the GetOrganizationUser request.
func (client *Client) getOrganizationUserCreateRequest(ctx context.Context, userID string, organizationID string, options *ClientGetOrganizationUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrganizationUserHandleResponse handles the GetOrganizationUser response.
func (client *Client) getOrganizationUserHandleResponse(resp *http.Response) (ClientGetOrganizationUserResponse, error) {
	result := ClientGetOrganizationUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetOrganizationUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetOrganizationUserMe - Gets a User A User matching the current authenticated user.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetOrganizationUserMeOptions contains the optional parameters for the Client.GetOrganizationUserMe method.
func (client *Client) GetOrganizationUserMe(ctx context.Context, organizationID string, options *ClientGetOrganizationUserMeOptions) (ClientGetOrganizationUserMeResponse, error) {
	req, err := client.getOrganizationUserMeCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetOrganizationUserMeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetOrganizationUserMeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetOrganizationUserMeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrganizationUserMeHandleResponse(resp)
}

// getOrganizationUserMeCreateRequest creates the GetOrganizationUserMe request.
func (client *Client) getOrganizationUserMeCreateRequest(ctx context.Context, organizationID string, options *ClientGetOrganizationUserMeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/me"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrganizationUserMeHandleResponse handles the GetOrganizationUserMe response.
func (client *Client) getOrganizationUserMeHandleResponse(resp *http.Response) (ClientGetOrganizationUserMeResponse, error) {
	result := ClientGetOrganizationUserMeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUserMeResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetOrganizationUserMeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetOrganizationUsers - Gets all Users.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetOrganizationUsersOptions contains the optional parameters for the Client.GetOrganizationUsers method.
func (client *Client) GetOrganizationUsers(ctx context.Context, organizationID string, options *ClientGetOrganizationUsersOptions) (ClientGetOrganizationUsersResponse, error) {
	req, err := client.getOrganizationUsersCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetOrganizationUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetOrganizationUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetOrganizationUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrganizationUsersHandleResponse(resp)
}

// getOrganizationUsersCreateRequest creates the GetOrganizationUsers request.
func (client *Client) getOrganizationUsersCreateRequest(ctx context.Context, organizationID string, options *ClientGetOrganizationUsersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrganizationUsersHandleResponse handles the GetOrganizationUsers response.
func (client *Client) getOrganizationUsersHandleResponse(resp *http.Response) (ClientGetOrganizationUsersResponse, error) {
	result := ClientGetOrganizationUsersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUsersResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUsersResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationUsersResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetOrganizationUsersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetOrganizations - Gets all Organizations.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetOrganizationsOptions contains the optional parameters for the Client.GetOrganizations method.
func (client *Client) GetOrganizations(ctx context.Context, options *ClientGetOrganizationsOptions) (ClientGetOrganizationsResponse, error) {
	req, err := client.getOrganizationsCreateRequest(ctx, options)
	if err != nil {
		return ClientGetOrganizationsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetOrganizationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetOrganizationsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getOrganizationsHandleResponse(resp)
}

// getOrganizationsCreateRequest creates the GetOrganizations request.
func (client *Client) getOrganizationsCreateRequest(ctx context.Context, options *ClientGetOrganizationsOptions) (*policy.Request, error) {
	urlPath := "/orgs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getOrganizationsHandleResponse handles the GetOrganizations response.
func (client *Client) getOrganizationsHandleResponse(resp *http.Response) (ClientGetOrganizationsResponse, error) {
	result := ClientGetOrganizationsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val OrganizationListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetOrganizationsResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetOrganizationsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProject - Gets a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectOptions contains the optional parameters for the Client.GetProject method.
func (client *Client) GetProject(ctx context.Context, projectID string, organizationID string, options *ClientGetProjectOptions) (ClientGetProjectResponse, error) {
	req, err := client.getProjectCreateRequest(ctx, projectID, organizationID, options)
	if err != nil {
		return ClientGetProjectResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectHandleResponse(resp)
}

// getProjectCreateRequest creates the GetProject request.
func (client *Client) getProjectCreateRequest(ctx context.Context, projectID string, organizationID string, options *ClientGetProjectOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}"
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectHandleResponse handles the GetProject response.
func (client *Client) getProjectHandleResponse(resp *http.Response) (ClientGetProjectResponse, error) {
	result := ClientGetProjectResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectIdentities - Gets all Project Identities.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectIdentitiesOptions contains the optional parameters for the Client.GetProjectIdentities method.
func (client *Client) GetProjectIdentities(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectIdentitiesOptions) (ClientGetProjectIdentitiesResponse, error) {
	req, err := client.getProjectIdentitiesCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectIdentitiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectIdentitiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetProjectIdentitiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectIdentitiesHandleResponse(resp)
}

// getProjectIdentitiesCreateRequest creates the GetProjectIdentities request.
func (client *Client) getProjectIdentitiesCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectIdentitiesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/identities"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectIdentitiesHandleResponse handles the GetProjectIdentities response.
func (client *Client) getProjectIdentitiesHandleResponse(resp *http.Response) (ClientGetProjectIdentitiesResponse, error) {
	result := ClientGetProjectIdentitiesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectIdentityListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectIdentitiesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectIdentitiesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetProjectIdentitiesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectIdentity - Gets a Project Identity.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectIdentityOptions contains the optional parameters for the Client.GetProjectIdentity method.
func (client *Client) GetProjectIdentity(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientGetProjectIdentityOptions) (ClientGetProjectIdentityResponse, error) {
	req, err := client.getProjectIdentityCreateRequest(ctx, projectIdentityID, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectIdentityResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectIdentityResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectIdentityResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectIdentityHandleResponse(resp)
}

// getProjectIdentityCreateRequest creates the GetProjectIdentity request.
func (client *Client) getProjectIdentityCreateRequest(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientGetProjectIdentityOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"
	if projectIdentityID == "" {
		return nil, errors.New("parameter projectIdentityID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectIdentityId}", url.PathEscape(projectIdentityID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectIdentityHandleResponse handles the GetProjectIdentity response.
func (client *Client) getProjectIdentityHandleResponse(resp *http.Response) (ClientGetProjectIdentityResponse, error) {
	result := ClientGetProjectIdentityResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectIdentityDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectIdentityResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectIdentityResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectStatus - Gets the status of a long-running operation.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectStatusOptions contains the optional parameters for the Client.GetProjectStatus method.
func (client *Client) GetProjectStatus(ctx context.Context, projectID string, trackingID string, organizationID string, options *ClientGetProjectStatusOptions) (ClientGetProjectStatusResponse, error) {
	req, err := client.getProjectStatusCreateRequest(ctx, projectID, trackingID, organizationID, options)
	if err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectStatusHandleResponse(resp)
}

// getProjectStatusCreateRequest creates the GetProjectStatus request.
func (client *Client) getProjectStatusCreateRequest(ctx context.Context, projectID string, trackingID string, organizationID string, options *ClientGetProjectStatusOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/status/{trackingId}"
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	urlPath = strings.ReplaceAll(urlPath, "{trackingId}", url.PathEscape(trackingID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectStatusHandleResponse handles the GetProjectStatus response.
func (client *Client) getProjectStatusHandleResponse(resp *http.Response) (ClientGetProjectStatusResponse, error) {
	result := ClientGetProjectStatusResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectStatusResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectStatusResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectTagByKey - Gets a Project Tag by Key.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectTagByKeyOptions contains the optional parameters for the Client.GetProjectTagByKey method.
func (client *Client) GetProjectTagByKey(ctx context.Context, tagKey string, organizationID string, projectID string, options *ClientGetProjectTagByKeyOptions) (ClientGetProjectTagByKeyResponse, error) {
	req, err := client.getProjectTagByKeyCreateRequest(ctx, tagKey, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectTagByKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectTagByKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectTagByKeyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectTagByKeyHandleResponse(resp)
}

// getProjectTagByKeyCreateRequest creates the GetProjectTagByKey request.
func (client *Client) getProjectTagByKeyCreateRequest(ctx context.Context, tagKey string, organizationID string, projectID string, options *ClientGetProjectTagByKeyOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}"
	if tagKey == "" {
		return nil, errors.New("parameter tagKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{tagKey}", url.PathEscape(tagKey))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectTagByKeyHandleResponse handles the GetProjectTagByKey response.
func (client *Client) getProjectTagByKeyHandleResponse(resp *http.Response) (ClientGetProjectTagByKeyResponse, error) {
	result := ClientGetProjectTagByKeyResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StringDictionaryDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagByKeyResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagByKeyResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagByKeyResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectTagByKeyResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectTags - Gets all Tags for a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectTagsOptions contains the optional parameters for the Client.GetProjectTags method.
func (client *Client) GetProjectTags(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectTagsOptions) (ClientGetProjectTagsResponse, error) {
	req, err := client.getProjectTagsCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectTagsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectTagsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectTagsHandleResponse(resp)
}

// getProjectTagsCreateRequest creates the GetProjectTags request.
func (client *Client) getProjectTagsCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectTagsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/tags"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectTagsHandleResponse handles the GetProjectTags response.
func (client *Client) getProjectTagsHandleResponse(resp *http.Response) (ClientGetProjectTagsResponse, error) {
	result := ClientGetProjectTagsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StringDictionaryDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTagsResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectTagsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectTemplate - Gets a Project Template.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectTemplateOptions contains the optional parameters for the Client.GetProjectTemplate method.
func (client *Client) GetProjectTemplate(ctx context.Context, projectTemplateID string, organizationID string, options *ClientGetProjectTemplateOptions) (ClientGetProjectTemplateResponse, error) {
	req, err := client.getProjectTemplateCreateRequest(ctx, projectTemplateID, organizationID, options)
	if err != nil {
		return ClientGetProjectTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectTemplateHandleResponse(resp)
}

// getProjectTemplateCreateRequest creates the GetProjectTemplate request.
func (client *Client) getProjectTemplateCreateRequest(ctx context.Context, projectTemplateID string, organizationID string, options *ClientGetProjectTemplateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/templates/{projectTemplateId}"
	if projectTemplateID == "" {
		return nil, errors.New("parameter projectTemplateID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectTemplateId}", url.PathEscape(projectTemplateID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectTemplateHandleResponse handles the GetProjectTemplate response.
func (client *Client) getProjectTemplateHandleResponse(resp *http.Response) (ClientGetProjectTemplateResponse, error) {
	result := ClientGetProjectTemplateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectTemplateDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTemplateResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectTemplateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectTemplates - Gets all Project Templates.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectTemplatesOptions contains the optional parameters for the Client.GetProjectTemplates method.
func (client *Client) GetProjectTemplates(ctx context.Context, organizationID string, options *ClientGetProjectTemplatesOptions) (ClientGetProjectTemplatesResponse, error) {
	req, err := client.getProjectTemplatesCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetProjectTemplatesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectTemplatesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetProjectTemplatesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectTemplatesHandleResponse(resp)
}

// getProjectTemplatesCreateRequest creates the GetProjectTemplates request.
func (client *Client) getProjectTemplatesCreateRequest(ctx context.Context, organizationID string, options *ClientGetProjectTemplatesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/templates"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectTemplatesHandleResponse handles the GetProjectTemplates response.
func (client *Client) getProjectTemplatesHandleResponse(resp *http.Response) (ClientGetProjectTemplatesResponse, error) {
	result := ClientGetProjectTemplatesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectTemplateListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTemplatesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectTemplatesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetProjectTemplatesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectUser - Gets a Project User by ID or email address.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectUserOptions contains the optional parameters for the Client.GetProjectUser method.
func (client *Client) GetProjectUser(ctx context.Context, userID string, organizationID string, projectID string, options *ClientGetProjectUserOptions) (ClientGetProjectUserResponse, error) {
	req, err := client.getProjectUserCreateRequest(ctx, userID, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectUserHandleResponse(resp)
}

// getProjectUserCreateRequest creates the GetProjectUser request.
func (client *Client) getProjectUserCreateRequest(ctx context.Context, userID string, organizationID string, projectID string, options *ClientGetProjectUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectUserHandleResponse handles the GetProjectUser response.
func (client *Client) getProjectUserHandleResponse(resp *http.Response) (ClientGetProjectUserResponse, error) {
	result := ClientGetProjectUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectUserMe - Gets a Project User for the calling user.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectUserMeOptions contains the optional parameters for the Client.GetProjectUserMe method.
func (client *Client) GetProjectUserMe(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectUserMeOptions) (ClientGetProjectUserMeResponse, error) {
	req, err := client.getProjectUserMeCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectUserMeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectUserMeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectUserMeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectUserMeHandleResponse(resp)
}

// getProjectUserMeCreateRequest creates the GetProjectUserMe request.
func (client *Client) getProjectUserMeCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectUserMeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users/me"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectUserMeHandleResponse handles the GetProjectUserMe response.
func (client *Client) getProjectUserMeHandleResponse(resp *http.Response) (ClientGetProjectUserMeResponse, error) {
	result := ClientGetProjectUserMeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUserMeResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectUserMeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjectUsers - Gets all Users for a Project.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectUsersOptions contains the optional parameters for the Client.GetProjectUsers method.
func (client *Client) GetProjectUsers(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectUsersOptions) (ClientGetProjectUsersResponse, error) {
	req, err := client.getProjectUsersCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetProjectUsersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectUsersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetProjectUsersResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectUsersHandleResponse(resp)
}

// getProjectUsersCreateRequest creates the GetProjectUsers request.
func (client *Client) getProjectUsersCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetProjectUsersOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectUsersHandleResponse handles the GetProjectUsers response.
func (client *Client) getProjectUsersHandleResponse(resp *http.Response) (ClientGetProjectUsersResponse, error) {
	result := ClientGetProjectUsersResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUsersResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUsersResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectUsersResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetProjectUsersResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetProjects - Gets all Projects.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetProjectsOptions contains the optional parameters for the Client.GetProjects method.
func (client *Client) GetProjects(ctx context.Context, organizationID string, options *ClientGetProjectsOptions) (ClientGetProjectsResponse, error) {
	req, err := client.getProjectsCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetProjectsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetProjectsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetProjectsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getProjectsHandleResponse(resp)
}

// getProjectsCreateRequest creates the GetProjects request.
func (client *Client) getProjectsCreateRequest(ctx context.Context, organizationID string, options *ClientGetProjectsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProjectsHandleResponse handles the GetProjects response.
func (client *Client) getProjectsHandleResponse(resp *http.Response) (ClientGetProjectsResponse, error) {
	result := ClientGetProjectsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetProjectsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetProjectsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetSchedule - Gets the Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetScheduleOptions contains the optional parameters for the Client.GetSchedule method.
func (client *Client) GetSchedule(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientGetScheduleOptions) (ClientGetScheduleResponse, error) {
	req, err := client.getScheduleCreateRequest(ctx, scheduleID, organizationID, projectID, options)
	if err != nil {
		return ClientGetScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.getScheduleHandleResponse(resp)
}

// getScheduleCreateRequest creates the GetSchedule request.
func (client *Client) getScheduleCreateRequest(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientGetScheduleOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}"
	if scheduleID == "" {
		return nil, errors.New("parameter scheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scheduleId}", url.PathEscape(scheduleID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getScheduleHandleResponse handles the GetSchedule response.
func (client *Client) getScheduleHandleResponse(resp *http.Response) (ClientGetScheduleResponse, error) {
	result := ClientGetScheduleResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ScheduleDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetScheduleResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetScheduleResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetSchedules - Gets all Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetSchedulesOptions contains the optional parameters for the Client.GetSchedules method.
func (client *Client) GetSchedules(ctx context.Context, organizationID string, projectID string, options *ClientGetSchedulesOptions) (ClientGetSchedulesResponse, error) {
	req, err := client.getSchedulesCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientGetSchedulesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetSchedulesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientGetSchedulesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSchedulesHandleResponse(resp)
}

// getSchedulesCreateRequest creates the GetSchedules request.
func (client *Client) getSchedulesCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientGetSchedulesOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/schedules"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSchedulesHandleResponse handles the GetSchedules response.
func (client *Client) getSchedulesHandleResponse(resp *http.Response) (ClientGetSchedulesResponse, error) {
	result := ClientGetSchedulesResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ScheduleListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetSchedulesResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetSchedulesResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientGetSchedulesResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetStatus - Gets the status of a long-running operation.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetStatusOptions contains the optional parameters for the Client.GetStatus method.
func (client *Client) GetStatus(ctx context.Context, trackingID string, organizationID string, options *ClientGetStatusOptions) (ClientGetStatusResponse, error) {
	req, err := client.getStatusCreateRequest(ctx, trackingID, organizationID, options)
	if err != nil {
		return ClientGetStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetStatusResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStatusHandleResponse(resp)
}

// getStatusCreateRequest creates the GetStatus request.
func (client *Client) getStatusCreateRequest(ctx context.Context, trackingID string, organizationID string, options *ClientGetStatusOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/status/{trackingId}"
	urlPath = strings.ReplaceAll(urlPath, "{trackingId}", url.PathEscape(trackingID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getStatusHandleResponse handles the GetStatus response.
func (client *Client) getStatusHandleResponse(resp *http.Response) (ClientGetStatusResponse, error) {
	result := ClientGetStatusResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetStatusResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetStatusResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetStatusResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetStatusResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetStatusResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetUserProjects - Gets all Projects for a User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetUserProjectsOptions contains the optional parameters for the Client.GetUserProjects method.
func (client *Client) GetUserProjects(ctx context.Context, organizationID string, userID string, options *ClientGetUserProjectsOptions) (ClientGetUserProjectsResponse, error) {
	req, err := client.getUserProjectsCreateRequest(ctx, organizationID, userID, options)
	if err != nil {
		return ClientGetUserProjectsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetUserProjectsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetUserProjectsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUserProjectsHandleResponse(resp)
}

// getUserProjectsCreateRequest creates the GetUserProjects request.
func (client *Client) getUserProjectsCreateRequest(ctx context.Context, organizationID string, userID string, options *ClientGetUserProjectsOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users/{userId}/projects"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProjectsHandleResponse handles the GetUserProjects response.
func (client *Client) getUserProjectsHandleResponse(resp *http.Response) (ClientGetUserProjectsResponse, error) {
	result := ClientGetUserProjectsResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetUserProjectsResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// GetUserProjectsMe - Gets all Projects for a User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientGetUserProjectsMeOptions contains the optional parameters for the Client.GetUserProjectsMe method.
func (client *Client) GetUserProjectsMe(ctx context.Context, organizationID string, options *ClientGetUserProjectsMeOptions) (ClientGetUserProjectsMeResponse, error) {
	req, err := client.getUserProjectsMeCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientGetUserProjectsMeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetUserProjectsMeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientGetUserProjectsMeResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUserProjectsMeHandleResponse(resp)
}

// getUserProjectsMeCreateRequest creates the GetUserProjectsMe request.
func (client *Client) getUserProjectsMeCreateRequest(ctx context.Context, organizationID string, options *ClientGetUserProjectsMeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/me/projects"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUserProjectsMeHandleResponse handles the GetUserProjectsMe response.
func (client *Client) getUserProjectsMeHandleResponse(resp *http.Response) (ClientGetUserProjectsMeResponse, error) {
	result := ClientGetUserProjectsMeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectListDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsMeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsMeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientGetUserProjectsMeResponse{}, err
	}
	result.Value = val
	default:
		return ClientGetUserProjectsMeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// InitializeAuthorization - Initialize a new authorization session for a deployment scope.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientInitializeAuthorizationOptions contains the optional parameters for the Client.InitializeAuthorization
// method.
func (client *Client) InitializeAuthorization(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientInitializeAuthorizationOptions) (ClientInitializeAuthorizationResponse, error) {
	req, err := client.initializeAuthorizationCreateRequest(ctx, organizationID, deploymentScopeID, options)
	if err != nil {
		return ClientInitializeAuthorizationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientInitializeAuthorizationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientInitializeAuthorizationResponse{}, runtime.NewResponseError(resp)
	}
	return client.initializeAuthorizationHandleResponse(resp)
}

// initializeAuthorizationCreateRequest creates the InitializeAuthorization request.
func (client *Client) initializeAuthorizationCreateRequest(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientInitializeAuthorizationOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes/{deploymentScopeId}/authorize/initialize"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if deploymentScopeID == "" {
		return nil, errors.New("parameter deploymentScopeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentScopeId}", url.PathEscape(deploymentScopeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// initializeAuthorizationHandleResponse handles the InitializeAuthorization response.
func (client *Client) initializeAuthorizationHandleResponse(resp *http.Response) (ClientInitializeAuthorizationResponse, error) {
	result := ClientInitializeAuthorizationResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeploymentScopeDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientInitializeAuthorizationResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientInitializeAuthorizationResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	default:
		return ClientInitializeAuthorizationResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// NegotiateSignalR - Negotiates the SignalR connection.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientNegotiateSignalROptions contains the optional parameters for the Client.NegotiateSignalR method.
func (client *Client) NegotiateSignalR(ctx context.Context, organizationID string, projectID string, options *ClientNegotiateSignalROptions) (ClientNegotiateSignalRResponse, error) {
	req, err := client.negotiateSignalRCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientNegotiateSignalRResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientNegotiateSignalRResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusUnauthorized, http.StatusForbidden) {
		return ClientNegotiateSignalRResponse{}, runtime.NewResponseError(resp)
	}
	return ClientNegotiateSignalRResponse{}, nil
}

// negotiateSignalRCreateRequest creates the NegotiateSignalR request.
func (client *Client) negotiateSignalRCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientNegotiateSignalROptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/negotiate"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// ReRunComponentTask - Rerun a Project Component Task.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientReRunComponentTaskOptions contains the optional parameters for the Client.ReRunComponentTask method.
func (client *Client) ReRunComponentTask(ctx context.Context, organizationID string, projectID string, componentID string, taskID string, options *ClientReRunComponentTaskOptions) (ClientReRunComponentTaskResponse, error) {
	req, err := client.reRunComponentTaskCreateRequest(ctx, organizationID, projectID, componentID, taskID, options)
	if err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientReRunComponentTaskResponse{}, runtime.NewResponseError(resp)
	}
	return client.reRunComponentTaskHandleResponse(resp)
}

// reRunComponentTaskCreateRequest creates the ReRunComponentTask request.
func (client *Client) reRunComponentTaskCreateRequest(ctx context.Context, organizationID string, projectID string, componentID string, taskID string, options *ClientReRunComponentTaskOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/rerun"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	if componentID == "" {
		return nil, errors.New("parameter componentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{componentId}", url.PathEscape(componentID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// reRunComponentTaskHandleResponse handles the ReRunComponentTask response.
func (client *Client) reRunComponentTaskHandleResponse(resp *http.Response) (ClientReRunComponentTaskResponse, error) {
	result := ClientReRunComponentTaskResponse{}
	switch resp.StatusCode {
	case http.StatusCreated:
	var val ComponentTaskDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientReRunComponentTaskResponse{}, err
	}
	result.Value = val
	default:
		return ClientReRunComponentTaskResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// RunSchedule - Runs a Project Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientRunScheduleOptions contains the optional parameters for the Client.RunSchedule method.
func (client *Client) RunSchedule(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientRunScheduleOptions) (ClientRunScheduleResponse, error) {
	req, err := client.runScheduleCreateRequest(ctx, scheduleID, organizationID, projectID, options)
	if err != nil {
		return ClientRunScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientRunScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientRunScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.runScheduleHandleResponse(resp)
}

// runScheduleCreateRequest creates the RunSchedule request.
func (client *Client) runScheduleCreateRequest(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientRunScheduleOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}/run"
	if scheduleID == "" {
		return nil, errors.New("parameter scheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scheduleId}", url.PathEscape(scheduleID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// runScheduleHandleResponse handles the RunSchedule response.
func (client *Client) runScheduleHandleResponse(resp *http.Response) (ClientRunScheduleResponse, error) {
	result := ClientRunScheduleResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ScheduleDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientRunScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientRunScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientRunScheduleResponse{}, err
	}
	result.Value = val
	default:
		return ClientRunScheduleResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateDeploymentScope - Updates an existing Deployment Scope.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateDeploymentScopeOptions contains the optional parameters for the Client.UpdateDeploymentScope method.
func (client *Client) UpdateDeploymentScope(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientUpdateDeploymentScopeOptions) (ClientUpdateDeploymentScopeResponse, error) {
	req, err := client.updateDeploymentScopeCreateRequest(ctx, organizationID, deploymentScopeID, options)
	if err != nil {
		return ClientUpdateDeploymentScopeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateDeploymentScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateDeploymentScopeResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateDeploymentScopeHandleResponse(resp)
}

// updateDeploymentScopeCreateRequest creates the UpdateDeploymentScope request.
func (client *Client) updateDeploymentScopeCreateRequest(ctx context.Context, organizationID string, deploymentScopeID string, options *ClientUpdateDeploymentScopeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/scopes/{deploymentScopeId}"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if deploymentScopeID == "" {
		return nil, errors.New("parameter deploymentScopeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentScopeId}", url.PathEscape(deploymentScopeID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateDeploymentScopeHandleResponse handles the UpdateDeploymentScope response.
func (client *Client) updateDeploymentScopeHandleResponse(resp *http.Response) (ClientUpdateDeploymentScopeResponse, error) {
	result := ClientUpdateDeploymentScopeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val DeploymentScopeDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateDeploymentScopeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateDeploymentScopeResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateDeploymentScopeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateOrganizationUser - Updates an existing User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateOrganizationUserOptions contains the optional parameters for the Client.UpdateOrganizationUser method.
func (client *Client) UpdateOrganizationUser(ctx context.Context, userID string, organizationID string, options *ClientUpdateOrganizationUserOptions) (ClientUpdateOrganizationUserResponse, error) {
	req, err := client.updateOrganizationUserCreateRequest(ctx, userID, organizationID, options)
	if err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateOrganizationUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateOrganizationUserHandleResponse(resp)
}

// updateOrganizationUserCreateRequest creates the UpdateOrganizationUser request.
func (client *Client) updateOrganizationUserCreateRequest(ctx context.Context, userID string, organizationID string, options *ClientUpdateOrganizationUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateOrganizationUserHandleResponse handles the UpdateOrganizationUser response.
func (client *Client) updateOrganizationUserHandleResponse(resp *http.Response) (ClientUpdateOrganizationUserResponse, error) {
	result := ClientUpdateOrganizationUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateOrganizationUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateOrganizationUserMe - Updates an existing User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateOrganizationUserMeOptions contains the optional parameters for the Client.UpdateOrganizationUserMe
// method.
func (client *Client) UpdateOrganizationUserMe(ctx context.Context, organizationID string, options *ClientUpdateOrganizationUserMeOptions) (ClientUpdateOrganizationUserMeResponse, error) {
	req, err := client.updateOrganizationUserMeCreateRequest(ctx, organizationID, options)
	if err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateOrganizationUserMeResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateOrganizationUserMeHandleResponse(resp)
}

// updateOrganizationUserMeCreateRequest creates the UpdateOrganizationUserMe request.
func (client *Client) updateOrganizationUserMeCreateRequest(ctx context.Context, organizationID string, options *ClientUpdateOrganizationUserMeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/me"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateOrganizationUserMeHandleResponse handles the UpdateOrganizationUserMe response.
func (client *Client) updateOrganizationUserMeHandleResponse(resp *http.Response) (ClientUpdateOrganizationUserMeResponse, error) {
	result := ClientUpdateOrganizationUserMeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateOrganizationUserMeResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateOrganizationUserMeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateProjectIdentity - Updates an existing Project Identity.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateProjectIdentityOptions contains the optional parameters for the Client.UpdateProjectIdentity method.
func (client *Client) UpdateProjectIdentity(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientUpdateProjectIdentityOptions) (ClientUpdateProjectIdentityResponse, error) {
	req, err := client.updateProjectIdentityCreateRequest(ctx, projectIdentityID, organizationID, projectID, options)
	if err != nil {
		return ClientUpdateProjectIdentityResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateProjectIdentityResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateProjectIdentityResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateProjectIdentityHandleResponse(resp)
}

// updateProjectIdentityCreateRequest creates the UpdateProjectIdentity request.
func (client *Client) updateProjectIdentityCreateRequest(ctx context.Context, projectIdentityID string, organizationID string, projectID string, options *ClientUpdateProjectIdentityOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"
	if projectIdentityID == "" {
		return nil, errors.New("parameter projectIdentityID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectIdentityId}", url.PathEscape(projectIdentityID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateProjectIdentityHandleResponse handles the UpdateProjectIdentity response.
func (client *Client) updateProjectIdentityHandleResponse(resp *http.Response) (ClientUpdateProjectIdentityResponse, error) {
	result := ClientUpdateProjectIdentityResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectIdentityResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectIdentityResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateProjectIdentityResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateProjectTag - Updates an existing Project Tag.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateProjectTagOptions contains the optional parameters for the Client.UpdateProjectTag method.
func (client *Client) UpdateProjectTag(ctx context.Context, organizationID string, projectID string, options *ClientUpdateProjectTagOptions) (ClientUpdateProjectTagResponse, error) {
	req, err := client.updateProjectTagCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientUpdateProjectTagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateProjectTagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateProjectTagResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateProjectTagHandleResponse(resp)
}

// updateProjectTagCreateRequest creates the UpdateProjectTag request.
func (client *Client) updateProjectTagCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientUpdateProjectTagOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/tags"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, options.Body)
	}
	return req, nil
}

// updateProjectTagHandleResponse handles the UpdateProjectTag response.
func (client *Client) updateProjectTagHandleResponse(resp *http.Response) (ClientUpdateProjectTagResponse, error) {
	result := ClientUpdateProjectTagResponse{}
	switch resp.StatusCode {
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTagResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTagResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateProjectTagResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateProjectTemplate - Updates an existing Project Template.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateProjectTemplateOptions contains the optional parameters for the Client.UpdateProjectTemplate method.
func (client *Client) UpdateProjectTemplate(ctx context.Context, projectTemplateID string, organizationID string, options *ClientUpdateProjectTemplateOptions) (ClientUpdateProjectTemplateResponse, error) {
	req, err := client.updateProjectTemplateCreateRequest(ctx, projectTemplateID, organizationID, options)
	if err != nil {
		return ClientUpdateProjectTemplateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateProjectTemplateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateProjectTemplateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateProjectTemplateHandleResponse(resp)
}

// updateProjectTemplateCreateRequest creates the UpdateProjectTemplate request.
func (client *Client) updateProjectTemplateCreateRequest(ctx context.Context, projectTemplateID string, organizationID string, options *ClientUpdateProjectTemplateOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/templates/{projectTemplateId}"
	if projectTemplateID == "" {
		return nil, errors.New("parameter projectTemplateID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectTemplateId}", url.PathEscape(projectTemplateID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateProjectTemplateHandleResponse handles the UpdateProjectTemplate response.
func (client *Client) updateProjectTemplateHandleResponse(resp *http.Response) (ClientUpdateProjectTemplateResponse, error) {
	result := ClientUpdateProjectTemplateResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ProjectTemplateDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTemplateResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectTemplateResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateProjectTemplateResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateProjectUser - Updates an existing Project User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateProjectUserOptions contains the optional parameters for the Client.UpdateProjectUser method.
func (client *Client) UpdateProjectUser(ctx context.Context, userID string, organizationID string, projectID string, options *ClientUpdateProjectUserOptions) (ClientUpdateProjectUserResponse, error) {
	req, err := client.updateProjectUserCreateRequest(ctx, userID, organizationID, projectID, options)
	if err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateProjectUserResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateProjectUserHandleResponse(resp)
}

// updateProjectUserCreateRequest creates the UpdateProjectUser request.
func (client *Client) updateProjectUserCreateRequest(ctx context.Context, userID string, organizationID string, projectID string, options *ClientUpdateProjectUserOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users/{userId}"
	if userID == "" {
		return nil, errors.New("parameter userID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userId}", url.PathEscape(userID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateProjectUserHandleResponse handles the UpdateProjectUser response.
func (client *Client) updateProjectUserHandleResponse(resp *http.Response) (ClientUpdateProjectUserResponse, error) {
	result := ClientUpdateProjectUserResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateProjectUserResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateProjectUserMe - Updates an existing Project User.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateProjectUserMeOptions contains the optional parameters for the Client.UpdateProjectUserMe method.
func (client *Client) UpdateProjectUserMe(ctx context.Context, organizationID string, projectID string, options *ClientUpdateProjectUserMeOptions) (ClientUpdateProjectUserMeResponse, error) {
	req, err := client.updateProjectUserMeCreateRequest(ctx, organizationID, projectID, options)
	if err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound) {
		return ClientUpdateProjectUserMeResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateProjectUserMeHandleResponse(resp)
}

// updateProjectUserMeCreateRequest creates the UpdateProjectUserMe request.
func (client *Client) updateProjectUserMeCreateRequest(ctx context.Context, organizationID string, projectID string, options *ClientUpdateProjectUserMeOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/users/me"
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateProjectUserMeHandleResponse handles the UpdateProjectUserMe response.
func (client *Client) updateProjectUserMeHandleResponse(resp *http.Response) (ClientUpdateProjectUserMeResponse, error) {
	result := ClientUpdateProjectUserMeResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val UserDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusAccepted:
	var val StatusResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateProjectUserMeResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateProjectUserMeResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

// UpdateSchedule - Updates a Project Schedule.
// If the operation fails it returns an *azcore.ResponseError type.
// options - ClientUpdateScheduleOptions contains the optional parameters for the Client.UpdateSchedule method.
func (client *Client) UpdateSchedule(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientUpdateScheduleOptions) (ClientUpdateScheduleResponse, error) {
	req, err := client.updateScheduleCreateRequest(ctx, scheduleID, organizationID, projectID, options)
	if err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusConflict) {
		return ClientUpdateScheduleResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateScheduleHandleResponse(resp)
}

// updateScheduleCreateRequest creates the UpdateSchedule request.
func (client *Client) updateScheduleCreateRequest(ctx context.Context, scheduleID string, organizationID string, projectID string, options *ClientUpdateScheduleOptions) (*policy.Request, error) {
	urlPath := "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}"
	if scheduleID == "" {
		return nil, errors.New("parameter scheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scheduleId}", url.PathEscape(scheduleID))
	if organizationID == "" {
		return nil, errors.New("parameter organizationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{organizationId}", url.PathEscape(organizationID))
	if projectID == "" {
		return nil, errors.New("parameter projectID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{projectId}", url.PathEscape(projectID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header.Set("Accept", "application/json")
	if options != nil && options.Body != nil {
		return req, runtime.MarshalAsJSON(req, *options.Body)
	}
	return req, nil
}

// updateScheduleHandleResponse handles the UpdateSchedule response.
func (client *Client) updateScheduleHandleResponse(resp *http.Response) (ClientUpdateScheduleResponse, error) {
	result := ClientUpdateScheduleResponse{}
	switch resp.StatusCode {
	case http.StatusOK:
	var val ScheduleDataResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusBadRequest:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusUnauthorized:
	case http.StatusForbidden:
	case http.StatusNotFound:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	result.Value = val
	case http.StatusConflict:
	var val ErrorResult
	if err := runtime.UnmarshalAsJSON(resp, &val); err != nil {
		return ClientUpdateScheduleResponse{}, err
	}
	result.Value = val
	default:
		return ClientUpdateScheduleResponse{}, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
	return result, nil
}

